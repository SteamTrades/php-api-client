<?php
/**
 * TradeApi
 * PHP version 5
 *
 * @category Class
 * @package  SteamTrades
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * SteamTrades API
 *
 * API Explorer for SteamTrades' RESTful API.
 *
 * OpenAPI spec version: 1.0
 * Contact: devs@steamtrad.es
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace SteamTrades\Api;

use \SteamTrades\ApiClient;
use \SteamTrades\ApiException;
use \SteamTrades\Configuration;
use \SteamTrades\ObjectSerializer;

/**
 * TradeApi Class Doc Comment
 *
 * @category Class
 * @package  SteamTrades
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TradeApi
{
    /**
     * API Client
     *
     * @var \SteamTrades\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \SteamTrades\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\SteamTrades\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \SteamTrades\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \SteamTrades\ApiClient $apiClient set the API client
     *
     * @return TradeApi
     */
    public function setApiClient(\SteamTrades\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation gameGet
     *
     * List supported games
     *
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\Game[]
     */
    public function gameGet()
    {
        list($response) = $this->gameGetWithHttpInfo();
        return $response;
    }

    /**
     * Operation gameGetWithHttpInfo
     *
     * List supported games
     *
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\Game[], HTTP status code, HTTP response headers (array of strings)
     */
    public function gameGetWithHttpInfo()
    {
        // parse inputs
        $resourcePath = "/game/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\Game[]',
                '/game/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\Game[]', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\Game[]', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation gameIdGet
     *
     * Info about a game
     *
     * @param string $id Game ID (e.g. 730 for CS:GO). (required)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\Game
     */
    public function gameIdGet($id)
    {
        list($response) = $this->gameIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation gameIdGetWithHttpInfo
     *
     * Info about a game
     *
     * @param string $id Game ID (e.g. 730 for CS:GO). (required)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\Game, HTTP status code, HTTP response headers (array of strings)
     */
    public function gameIdGetWithHttpInfo($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling gameIdGet');
        }
        // parse inputs
        $resourcePath = "/game/{id}/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\Game',
                '/game/{id}/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\Game', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\Game', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation itemMineGet
     *
     * List owned items
     *
     * @param string $context_id Inventory context ID for filtering. (optional)
     * @param int $offset Offset to start listing (optional, default to 0)
     * @param int $limit Number of trades to retrieve (optional, default to 250)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\InlineResponse200
     */
    public function itemMineGet($context_id = null, $offset = null, $limit = null)
    {
        list($response) = $this->itemMineGetWithHttpInfo($context_id, $offset, $limit);
        return $response;
    }

    /**
     * Operation itemMineGetWithHttpInfo
     *
     * List owned items
     *
     * @param string $context_id Inventory context ID for filtering. (optional)
     * @param int $offset Offset to start listing (optional, default to 0)
     * @param int $limit Number of trades to retrieve (optional, default to 250)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\InlineResponse200, HTTP status code, HTTP response headers (array of strings)
     */
    public function itemMineGetWithHttpInfo($context_id = null, $offset = null, $limit = null)
    {
        if (!is_null($limit) && ($limit > 1000)) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling TradeApi.itemMineGet, must be smaller than or equal to 1000.');
        }

        // parse inputs
        $resourcePath = "/item/mine/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($context_id !== null) {
            $queryParams['context_id'] = $this->apiClient->getSerializer()->toQueryValue($context_id);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = $this->apiClient->getSerializer()->toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = $this->apiClient->getSerializer()->toQueryValue($limit);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\InlineResponse200',
                '/item/mine/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\InlineResponse200', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse200', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation itemScanUserInventoryPost
     *
     * Scan Steam user inventory
     *
     * @param string $trade_url Trade URL of the target user. (required)
     * @param string $context_id Inventory context ID to retrieve items for. (required)
     * @param bool $force_refresh Do not use cached info (if exists), force rescan. (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\InlineResponse2001
     */
    public function itemScanUserInventoryPost($trade_url, $context_id, $force_refresh = null)
    {
        list($response) = $this->itemScanUserInventoryPostWithHttpInfo($trade_url, $context_id, $force_refresh);
        return $response;
    }

    /**
     * Operation itemScanUserInventoryPostWithHttpInfo
     *
     * Scan Steam user inventory
     *
     * @param string $trade_url Trade URL of the target user. (required)
     * @param string $context_id Inventory context ID to retrieve items for. (required)
     * @param bool $force_refresh Do not use cached info (if exists), force rescan. (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\InlineResponse2001, HTTP status code, HTTP response headers (array of strings)
     */
    public function itemScanUserInventoryPostWithHttpInfo($trade_url, $context_id, $force_refresh = null)
    {
        // verify the required parameter 'trade_url' is set
        if ($trade_url === null) {
            throw new \InvalidArgumentException('Missing the required parameter $trade_url when calling itemScanUserInventoryPost');
        }
        // verify the required parameter 'context_id' is set
        if ($context_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $context_id when calling itemScanUserInventoryPost');
        }
        // parse inputs
        $resourcePath = "/item/scan_user_inventory/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($trade_url !== null) {
            $queryParams['trade_url'] = $this->apiClient->getSerializer()->toQueryValue($trade_url);
        }
        // query params
        if ($context_id !== null) {
            $queryParams['context_id'] = $this->apiClient->getSerializer()->toQueryValue($context_id);
        }
        // query params
        if ($force_refresh !== null) {
            $queryParams['force_refresh'] = $this->apiClient->getSerializer()->toQueryValue($force_refresh);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\InlineResponse2001',
                '/item/scan_user_inventory/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\InlineResponse2001', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse2001', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation itemUserInventoryGet
     *
     * Get inventory scan results
     *
     * @param string $trade_url Trade URL of the target user. (required)
     * @param string $context_id Inventory context ID to retrieve items for. (required)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\ScannedItem[]
     */
    public function itemUserInventoryGet($trade_url, $context_id)
    {
        list($response) = $this->itemUserInventoryGetWithHttpInfo($trade_url, $context_id);
        return $response;
    }

    /**
     * Operation itemUserInventoryGetWithHttpInfo
     *
     * Get inventory scan results
     *
     * @param string $trade_url Trade URL of the target user. (required)
     * @param string $context_id Inventory context ID to retrieve items for. (required)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\ScannedItem[], HTTP status code, HTTP response headers (array of strings)
     */
    public function itemUserInventoryGetWithHttpInfo($trade_url, $context_id)
    {
        // verify the required parameter 'trade_url' is set
        if ($trade_url === null) {
            throw new \InvalidArgumentException('Missing the required parameter $trade_url when calling itemUserInventoryGet');
        }
        // verify the required parameter 'context_id' is set
        if ($context_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $context_id when calling itemUserInventoryGet');
        }
        // parse inputs
        $resourcePath = "/item/user_inventory/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($trade_url !== null) {
            $queryParams['trade_url'] = $this->apiClient->getSerializer()->toQueryValue($trade_url);
        }
        // query params
        if ($context_id !== null) {
            $queryParams['context_id'] = $this->apiClient->getSerializer()->toQueryValue($context_id);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\ScannedItem[]',
                '/item/user_inventory/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\ScannedItem[]', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\ScannedItem[]', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation tradeGet
     *
     * List your trades
     *
     * @param string[] $filter_ids If passed, returns only trades with given IDs (optional)
     * @param int $offset Offset to start listing (optional, default to 0)
     * @param int $limit Number of trades to retrieve (optional, default to 250)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\InlineResponse2002
     */
    public function tradeGet($filter_ids = null, $offset = null, $limit = null)
    {
        list($response) = $this->tradeGetWithHttpInfo($filter_ids, $offset, $limit);
        return $response;
    }

    /**
     * Operation tradeGetWithHttpInfo
     *
     * List your trades
     *
     * @param string[] $filter_ids If passed, returns only trades with given IDs (optional)
     * @param int $offset Offset to start listing (optional, default to 0)
     * @param int $limit Number of trades to retrieve (optional, default to 250)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\InlineResponse2002, HTTP status code, HTTP response headers (array of strings)
     */
    public function tradeGetWithHttpInfo($filter_ids = null, $offset = null, $limit = null)
    {
        if (!is_null($limit) && ($limit > 1000)) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling TradeApi.tradeGet, must be smaller than or equal to 1000.');
        }

        // parse inputs
        $resourcePath = "/trade/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($filter_ids)) {
            $filter_ids = $this->apiClient->getSerializer()->serializeCollection($filter_ids, 'csv', true);
        }
        if ($filter_ids !== null) {
            $queryParams['filter_ids'] = $this->apiClient->getSerializer()->toQueryValue($filter_ids);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = $this->apiClient->getSerializer()->toQueryValue($offset);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = $this->apiClient->getSerializer()->toQueryValue($limit);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\InlineResponse2002',
                '/trade/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\InlineResponse2002', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse2002', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation tradeIdGet
     *
     * Get trade status
     *
     * @param string $id Trade ID to query information for. (required)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\Trade
     */
    public function tradeIdGet($id)
    {
        list($response) = $this->tradeIdGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation tradeIdGetWithHttpInfo
     *
     * Get trade status
     *
     * @param string $id Trade ID to query information for. (required)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\Trade, HTTP status code, HTTP response headers (array of strings)
     */
    public function tradeIdGetWithHttpInfo($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $id when calling tradeIdGet');
        }
        // parse inputs
        $resourcePath = "/trade/{id}/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                "{" . "id" . "}",
                $this->apiClient->getSerializer()->toPathValue($id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\Trade',
                '/trade/{id}/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\Trade', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\Trade', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation tradeRequestItemsPost
     *
     * Request items
     *
     * @param string $trade_url Trade URL of the user to request items from. (required)
     * @param string $context_id The context ID the asset IDs belong to. (required)
     * @param string[] $asset_ids Steam asset IDs of the items to request, separated by commas. (required)
     * @param string $message Message sent with this trade. You may use &#x60;{verify_url}&#x60; to define where the trade verification URL is inserted. If &#x60;{verify_url}&#x60; isn&#39;t used, the URL is just appended. You message is limited to 65 characters (excluding URL). (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\InlineResponse2003
     */
    public function tradeRequestItemsPost($trade_url, $context_id, $asset_ids, $message = null)
    {
        list($response) = $this->tradeRequestItemsPostWithHttpInfo($trade_url, $context_id, $asset_ids, $message);
        return $response;
    }

    /**
     * Operation tradeRequestItemsPostWithHttpInfo
     *
     * Request items
     *
     * @param string $trade_url Trade URL of the user to request items from. (required)
     * @param string $context_id The context ID the asset IDs belong to. (required)
     * @param string[] $asset_ids Steam asset IDs of the items to request, separated by commas. (required)
     * @param string $message Message sent with this trade. You may use &#x60;{verify_url}&#x60; to define where the trade verification URL is inserted. If &#x60;{verify_url}&#x60; isn&#39;t used, the URL is just appended. You message is limited to 65 characters (excluding URL). (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function tradeRequestItemsPostWithHttpInfo($trade_url, $context_id, $asset_ids, $message = null)
    {
        // verify the required parameter 'trade_url' is set
        if ($trade_url === null) {
            throw new \InvalidArgumentException('Missing the required parameter $trade_url when calling tradeRequestItemsPost');
        }
        // verify the required parameter 'context_id' is set
        if ($context_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $context_id when calling tradeRequestItemsPost');
        }
        // verify the required parameter 'asset_ids' is set
        if ($asset_ids === null) {
            throw new \InvalidArgumentException('Missing the required parameter $asset_ids when calling tradeRequestItemsPost');
        }
        // parse inputs
        $resourcePath = "/trade/request_items/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($trade_url !== null) {
            $queryParams['trade_url'] = $this->apiClient->getSerializer()->toQueryValue($trade_url);
        }
        // query params
        if ($context_id !== null) {
            $queryParams['context_id'] = $this->apiClient->getSerializer()->toQueryValue($context_id);
        }
        // query params
        if (is_array($asset_ids)) {
            $asset_ids = $this->apiClient->getSerializer()->serializeCollection($asset_ids, 'csv', true);
        }
        if ($asset_ids !== null) {
            $queryParams['asset_ids'] = $this->apiClient->getSerializer()->toQueryValue($asset_ids);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = $this->apiClient->getSerializer()->toQueryValue($message);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\InlineResponse2003',
                '/trade/request_items/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\InlineResponse2003', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse2003', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse404', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation tradeSendItemsPost
     *
     * Send items
     *
     * @param string $trade_url Trade URL of the user to send items to. (required)
     * @param string[] $items IDs of the items to send, separated by commas. (required)
     * @param string $message Message sent with this trade. You may use &#x60;{verify_url}&#x60; to define where the trade verification URL is inserted. If &#x60;{verify_url}&#x60; isn&#39;t used, the URL is just appended. You message is limited to 65 characters (excluding URL). (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\InlineResponse2005
     */
    public function tradeSendItemsPost($trade_url, $items, $message = null)
    {
        list($response) = $this->tradeSendItemsPostWithHttpInfo($trade_url, $items, $message);
        return $response;
    }

    /**
     * Operation tradeSendItemsPostWithHttpInfo
     *
     * Send items
     *
     * @param string $trade_url Trade URL of the user to send items to. (required)
     * @param string[] $items IDs of the items to send, separated by commas. (required)
     * @param string $message Message sent with this trade. You may use &#x60;{verify_url}&#x60; to define where the trade verification URL is inserted. If &#x60;{verify_url}&#x60; isn&#39;t used, the URL is just appended. You message is limited to 65 characters (excluding URL). (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function tradeSendItemsPostWithHttpInfo($trade_url, $items, $message = null)
    {
        // verify the required parameter 'trade_url' is set
        if ($trade_url === null) {
            throw new \InvalidArgumentException('Missing the required parameter $trade_url when calling tradeSendItemsPost');
        }
        // verify the required parameter 'items' is set
        if ($items === null) {
            throw new \InvalidArgumentException('Missing the required parameter $items when calling tradeSendItemsPost');
        }
        // parse inputs
        $resourcePath = "/trade/send_items/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($trade_url !== null) {
            $queryParams['trade_url'] = $this->apiClient->getSerializer()->toQueryValue($trade_url);
        }
        // query params
        if (is_array($items)) {
            $items = $this->apiClient->getSerializer()->serializeCollection($items, 'csv', true);
        }
        if ($items !== null) {
            $queryParams['items'] = $this->apiClient->getSerializer()->toQueryValue($items);
        }
        // query params
        if ($message !== null) {
            $queryParams['message'] = $this->apiClient->getSerializer()->toQueryValue($message);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\InlineResponse2005',
                '/trade/send_items/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\InlineResponse2005', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse2005', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse4041', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 423:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse423', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation tradeTransferItemsPost
     *
     * Transfer items
     *
     * @param string[] $items IDs of the items to transfer, separated by commas. (required)
     * @param int $dst_app_id ID of the app receiving the items. (required)
     * @param bool $allow_foreign_dst Whether to allow transfer to apps of other users. (optional, default to false)
     * @param bool $move_physically Whether to physically move the item to bots of the destination app (in case either the source or destination app, or both, have dedicated bots). Items are only moved phisically if this is required because source and destination app have different storage locations. All items that are in the physical trade (and thus not moved instantly) are listed in &#x60;items_in_trade&#x60;. (optional, default to false)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\InlineResponse2004
     */
    public function tradeTransferItemsPost($items, $dst_app_id, $allow_foreign_dst = null, $move_physically = null)
    {
        list($response) = $this->tradeTransferItemsPostWithHttpInfo($items, $dst_app_id, $allow_foreign_dst, $move_physically);
        return $response;
    }

    /**
     * Operation tradeTransferItemsPostWithHttpInfo
     *
     * Transfer items
     *
     * @param string[] $items IDs of the items to transfer, separated by commas. (required)
     * @param int $dst_app_id ID of the app receiving the items. (required)
     * @param bool $allow_foreign_dst Whether to allow transfer to apps of other users. (optional, default to false)
     * @param bool $move_physically Whether to physically move the item to bots of the destination app (in case either the source or destination app, or both, have dedicated bots). Items are only moved phisically if this is required because source and destination app have different storage locations. All items that are in the physical trade (and thus not moved instantly) are listed in &#x60;items_in_trade&#x60;. (optional, default to false)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\InlineResponse2004, HTTP status code, HTTP response headers (array of strings)
     */
    public function tradeTransferItemsPostWithHttpInfo($items, $dst_app_id, $allow_foreign_dst = null, $move_physically = null)
    {
        // verify the required parameter 'items' is set
        if ($items === null) {
            throw new \InvalidArgumentException('Missing the required parameter $items when calling tradeTransferItemsPost');
        }
        // verify the required parameter 'dst_app_id' is set
        if ($dst_app_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dst_app_id when calling tradeTransferItemsPost');
        }
        // parse inputs
        $resourcePath = "/trade/transfer_items/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if (is_array($items)) {
            $items = $this->apiClient->getSerializer()->serializeCollection($items, 'csv', true);
        }
        if ($items !== null) {
            $queryParams['items'] = $this->apiClient->getSerializer()->toQueryValue($items);
        }
        // query params
        if ($dst_app_id !== null) {
            $queryParams['dst_app_id'] = $this->apiClient->getSerializer()->toQueryValue($dst_app_id);
        }
        // query params
        if ($allow_foreign_dst !== null) {
            $queryParams['allow_foreign_dst'] = $this->apiClient->getSerializer()->toQueryValue($allow_foreign_dst);
        }
        // query params
        if ($move_physically !== null) {
            $queryParams['move_physically'] = $this->apiClient->getSerializer()->toQueryValue($move_physically);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\InlineResponse2004',
                '/trade/transfer_items/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\InlineResponse2004', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse2004', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse4041', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
                case 423:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\InlineResponse423', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation userInfoBySteamIdGet
     *
     * Steam user info by Steam ID
     *
     * @param string $steam_id Steam ID (64-bit) of the target user. (required)
     * @param bool $force_refresh Don&#39;t use cached results, force refresh. Defaults to &#x60;false&#x60;. (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\UserInfo
     */
    public function userInfoBySteamIdGet($steam_id, $force_refresh = null)
    {
        list($response) = $this->userInfoBySteamIdGetWithHttpInfo($steam_id, $force_refresh);
        return $response;
    }

    /**
     * Operation userInfoBySteamIdGetWithHttpInfo
     *
     * Steam user info by Steam ID
     *
     * @param string $steam_id Steam ID (64-bit) of the target user. (required)
     * @param bool $force_refresh Don&#39;t use cached results, force refresh. Defaults to &#x60;false&#x60;. (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\UserInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function userInfoBySteamIdGetWithHttpInfo($steam_id, $force_refresh = null)
    {
        // verify the required parameter 'steam_id' is set
        if ($steam_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $steam_id when calling userInfoBySteamIdGet');
        }
        // parse inputs
        $resourcePath = "/user/info_by_steam_id/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($steam_id !== null) {
            $queryParams['steam_id'] = $this->apiClient->getSerializer()->toQueryValue($steam_id);
        }
        // query params
        if ($force_refresh !== null) {
            $queryParams['force_refresh'] = $this->apiClient->getSerializer()->toQueryValue($force_refresh);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\UserInfo',
                '/user/info_by_steam_id/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\UserInfo', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\UserInfo', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation userInfoByTradeUrlGet
     *
     * Steam user info by trade URL
     *
     * @param string $trade_url Trade URL of the target user. (required)
     * @param bool $force_refresh Don&#39;t use cached results, force refresh. Defaults to &#x60;false&#x60;. (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return \SteamTrades\Models\UserInfo
     */
    public function userInfoByTradeUrlGet($trade_url, $force_refresh = null)
    {
        list($response) = $this->userInfoByTradeUrlGetWithHttpInfo($trade_url, $force_refresh);
        return $response;
    }

    /**
     * Operation userInfoByTradeUrlGetWithHttpInfo
     *
     * Steam user info by trade URL
     *
     * @param string $trade_url Trade URL of the target user. (required)
     * @param bool $force_refresh Don&#39;t use cached results, force refresh. Defaults to &#x60;false&#x60;. (optional)
     * @throws \SteamTrades\ApiException on non-2xx response
     * @return array of \SteamTrades\Models\UserInfo, HTTP status code, HTTP response headers (array of strings)
     */
    public function userInfoByTradeUrlGetWithHttpInfo($trade_url, $force_refresh = null)
    {
        // verify the required parameter 'trade_url' is set
        if ($trade_url === null) {
            throw new \InvalidArgumentException('Missing the required parameter $trade_url when calling userInfoByTradeUrlGet');
        }
        // parse inputs
        $resourcePath = "/user/info_by_trade_url/";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept([]);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType([]);

        // query params
        if ($trade_url !== null) {
            $queryParams['trade_url'] = $this->apiClient->getSerializer()->toQueryValue($trade_url);
        }
        // query params
        if ($force_refresh !== null) {
            $queryParams['force_refresh'] = $this->apiClient->getSerializer()->toQueryValue($force_refresh);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires API key authentication
        $apiKey = $this->apiClient->getApiKeyWithPrefix('Authorization');
        if (strlen($apiKey) !== 0) {
            $headerParams['Authorization'] = $apiKey;
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                '\SteamTrades\Models\UserInfo',
                '/user/info_by_trade_url/'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, '\SteamTrades\Models\UserInfo', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), '\SteamTrades\Models\UserInfo', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
